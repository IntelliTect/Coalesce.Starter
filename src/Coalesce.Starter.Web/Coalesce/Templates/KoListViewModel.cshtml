@inherits Microsoft.VisualStudio.Web.CodeGeneration.Templating.RazorTemplateBase
@using IntelliTect.Coalesce.TypeDefinition
@using IntelliTect.Coalesce.Utilities
@{
    ClassViewModel model = Model.Model;
    string typingReferencePath = "../..";
    string intellitectUtilitiesPath = "..";
    string moduleName = "ListViewModels";
    string viewModelModuleName = "ViewModels";
    string viewModelName = model.Name;
    if (!string.IsNullOrWhiteSpace(Model.AreaName))
    {
        typingReferencePath = "../../../..";
        intellitectUtilitiesPath = "../../../../scripts";
        moduleName = Model.AreaName + "." + moduleName;
        viewModelModuleName = Model.AreaName + "." + viewModelModuleName;
    }
    if (!string.IsNullOrWhiteSpace(Model.ModulePrefix))
    {
        moduleName = Model.ModulePrefix + "." + moduleName;
        viewModelModuleName = Model.ModulePrefix + "." + viewModelModuleName;
        viewModelName = Model.ModulePrefix + "." + viewModelName;
    }
}
@{ 
@:/// <reference path="@typingReferencePath/typings/tsd.d.ts" />
@:/// <reference path="@intellitectUtilitiesPath/Coalesce/intellitect.utilities.ts" />
@:/// <reference path="@intellitectUtilitiesPath/Coalesce/intellitect.ko.utilities.ts" />
}
@{ 
@:/// <reference path="./Ko.@(viewModelName).ts" />
}

// Knockout List View Model for: @(model.Name)
// Auto Generated Knockout List Bindings
// Copyright IntelliTect, @(DateTime.Now.Year)

var baseUrl = baseUrl || '';

module @moduleName {
    export var areaUrl = areaUrl || ((@string.IsNullOrWhiteSpace(Model.AreaName).ToString().ToLower()) ? baseUrl : baseUrl + '@Model.AreaName/');
    // Add an enum for all methods that are static and IQueryable
    export enum @(model.Name)DataSources {
            Default,
            @foreach(var method in model.BaseViewModel.Methods.Where(m => m.IsIQueryableOfParent && m.IsClientMethod && m.IsStatic).OrderBy(m => m.Name))
            {
            @:@method.Name,
            }
        }
    export class @(model.ListViewModelClassName) {
        // Query string to limit the list of items.
        public queryString: string = "";
        // Object that is passed as the query parameters.
        public query: any = null;
        // The custom code to run in order to pull the initial datasource to use for the collection that should be returned
        public listDataSource: @(model.Name)DataSources = @(model.Name)DataSources.Default;
        // String the represents the child object to load 
        public includes: string = "";
        // Whether or not alerts should be shown when loading fails.
        public showFailureAlerts: boolean = true;
        // List of items. This the main collection.
        public items: KnockoutObservableArray<@viewModelModuleName.@(model.ViewModelClassName)> = ko.observableArray([]);
        // Load the list.
		public load: (callback?: any) => void;
        // Adds a new item to the collection.
		public addNewItem: () => @viewModelModuleName.@(model.ViewModelClassName);
        // Deletes an item.
		public deleteItem: (item: @viewModelModuleName.@(model.ViewModelClassName)) => void;
        // True if the collection is loading.
		public isLoading: KnockoutObservable<boolean> = ko.observable(false);
        // Gets the count of items without getting all the items. Data put into count.
		public getCount: (callback?: any) => void;
        // The result of getCount() or the total on this page.
		public count: KnockoutObservable<number> = ko.observable(null);
        // Total count of items, even ones that are not on the page.
   		public totalCount: KnockoutObservable<number> = ko.observable(null);
        // Total page count
   		public pageCount: KnockoutObservable<number> = ko.observable(null);
        // Page number. This can be set to get a new page.
   		public page: KnockoutObservable<number> = ko.observable(1);
        // Number of items on a page.
   		public pageSize: KnockoutObservable<number> = ko.observable(10);
        // If a load failed, this is a message about why it failed.
   		public message: KnockoutObservable<string> = ko.observable(null);
        // Search criteria for the list. This can be exposed as a text box for searching.
   		public search: KnockoutObservable<string> = ko.observable("");
        // Specify the DTO that should be returned - must be a fully qualified type name
        public dto: KnockoutObservable<string> = ko.observable("");
        // If there is another page, this is true.
        public nextPageEnabled: KnockoutComputed<boolean>
        // If there is a previous page, this is true.
        public previousPageEnabled: KnockoutComputed<boolean>;
        // Gets the next page.
        public nextPage: () => void;
        // Gets the previous page.
        public previousPage: () => void;
        // Control order of results
        public orderBy: KnockoutObservable<string> = ko.observable("");
        public orderByDescending: KnockoutObservable<string> = ko.observable("");

        // True once the data has been loaded.
		public isLoaded: KnockoutObservable<boolean> = ko.observable(false);

        // Valid values
    @foreach (PropertyViewModel prop in model.Properties.Where(f => f.HasValidValues))
        {
        @:public @(prop.ValidValueListName.ToCamelCase()): KnockoutObservableArray<any> = ko.observableArray([]);
        @:public load@(prop.ValidValueListName): (callback: any) => void;
        }
    @foreach(var method in model.Methods.Where(m => m.IsStatic && m.IsClientMethod))
        {
        @:// Call server method (@method.Name)
        if (method.Comment.Length > 0)
        {
        @:// @(method.Comment)
        }
        @:public @method.JsVariable: (@method.TsParameters) => void;
        @:// Result of server method (@method.Name) strongly typed in a observable.
        @:public @method.JsVariableResult: @method.ReturnType.TsKnockoutType = @method.ReturnType.JsKnockoutType;
        @:// Result of server method (@method.Name) simply wrapped in an observable.
        @:public @method.JsVariableResultRaw: KnockoutObservable<any> = ko.observable();
        @:// True while the server method (@method.Name) is being called
        @:public @method.JsVariableIsLoading: KnockoutObservable<boolean> = ko.observable(false);
        @:// Error message for server method (@method.Name) if it fails.
        @:public @method.JsVariableMessage: KnockoutObservable<string> = ko.observable(null);
        @:// True if the server method (@method.Name) was successful.
        @:public @method.JsVariableWasSuccessful: KnockoutObservable<boolean> = ko.observable(null);
        @:// Presents a series of input boxes to call the server method (@method.Name)
        @:public @method.JsVariableUi: (callback?: any) => void;
        @:// Presents a modal with input boxes to call the server method (@method.Name)
        @:public @method.JsVariableModal: (callback?: any) => void;
        @:// Variable for method arguments to allow for easy binding
        @if (method.ClientParameters.Any())
        {
        @:public @method.JsVariableWithArgs: (args?: @(model.ListViewModelClassName).@(method.ArgsName), callback?: any) => void;
        @:
        @:public @(method.JsVariableArgs) = new @(model.ListViewModelClassName).@(method.ArgsName)(); 
        }
        @:
        }
        constructor() {
            var self = this; 
            var searchTimeout: number = 0;

            // Load the collection
            self.load = function(callback?: any) {
                intellitect.utilities.showBusy();
                if(self.query) {
                    self.queryString = $.param(self.query);
                }
                self.isLoading(true);

                var url = areaUrl + "@(model.ApiUrl)/List?includes=" + self.includes + "&page=" + self.page()
                            + "&pageSize=" + self.pageSize() + "&search=" + self.search()
                            + "&orderBy=" + self.orderBy() + "&orderByDescending=" + self.orderByDescending()
                            + "&listDataSource=";
    
                if (typeof self.listDataSource === "string") url += self.listDataSource;
                else url += @(model.Name)DataSources[self.listDataSource];

                if (self.queryString !== null && self.queryString !== "") url += "&" + self.queryString;

                $.ajax({ method: "GET",
                         url: url,
                        xhrFields: { withCredentials: true } })
                .done(function(data) {
                    self.items.removeAll();
                    for (var i in data.list) {
                        var model = new @viewModelModuleName.@(model.ViewModelClassName)(data.list[i]);
                        model.includes = self.includes;
                        model.onDelete(itemDeleted);
                        self.items.push(model);
                    }
                    self.count(data.list.length);
                    self.totalCount(data.totalCount);
                    self.pageCount(data.pageCount);
                    self.page(data.page);
                    self.message(data.message)
                    self.isLoaded(true);
                    if ($.isFunction(callback)) callback(self);
                })
                .fail(function(xhr) {
                    var errorMsg = "Unknown Error";
                    if (xhr.responseJSON && xhr.responseJSON.message) errorMsg = xhr.responseJSON.message;
                    self.message(errorMsg);
                    self.isLoaded(false);
                    
                    if (self.showFailureAlerts)
                        alert("Could not get list of @(model.Name) items: " + errorMsg);
                })
                .always(function() {
                    intellitect.utilities.hideBusy();
                    self.isLoading(false);
                });
            };

            // Paging
            self.nextPage = function() {
                if (self.nextPageEnabled()) {
                    self.page(self.page() + 1);
                    self.load();
                }
            }
            self.nextPageEnabled = ko.computed(function() {
                if (self.page() < self.pageCount()) return true;
                return false;
            })
            self.previousPage = function() {
                if (self.previousPageEnabled()) {
                    self.page(self.page() - 1);
                    self.load();
                }
            }
            self.previousPageEnabled = ko.computed(function() {
                if (self.page() > 1) return true;
                return false;
            })


            // Load the count
            self.getCount = function(callback?: any) {
                intellitect.utilities.showBusy();
                if (self.query) {
                    self.queryString = $.param(self.query);
                }
                $.ajax({ method: "GET",
                         url: areaUrl + "@(model.ApiUrl)/count?" + "listDataSource=" + @(model.Name)DataSources[self.listDataSource] + "&" + self.queryString,
                         xhrFields: { withCredentials: true } })
                .done(function(data) {
                    self.count(data);
                    if ($.isFunction(callback)) callback();
                })
                .fail(function() {
                    if (self.showFailureAlerts)
                        alert("Could not get count of @(model.Name) items.");
                })
                .always(function() {
                    intellitect.utilities.hideBusy();
                });
            };

            // Callback for when an item is deleted
            function itemDeleted(item) {
                self.items.remove(item);
            }

            // Adds a new item to the array.
            self.addNewItem = function()
            {
                var item = new @viewModelModuleName.@(model.ViewModelClassName)();
                self.items.push(item);
                return item;
            };

            // Deletes an item and removes it from the array.
            self.deleteItem = function(item: @viewModelModuleName.@(model.ViewModelClassName))
            {
                item.deleteItem();
            };

            self.pageSize.subscribe(function () {
                if (self.isLoaded()){
                    self.load();
                }
            });
            self.page.subscribe(function () {
                if (self.isLoaded() && !self.isLoading()){
                    self.load();
                }
            });
            self.search.subscribe(function () {
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                searchTimeout = setTimeout(function() {
                    searchTimeout = 0;
                    self.load();
                }, 300);
            });

    // Method Implementations
            @foreach (var method in model.Methods.Where(m => m.IsStatic && m.IsClientMethod))
            {
            <text>
            self.@method.JsVariable = function(@method.TsParameters.Replace("reload?: boolean", "reload: boolean = true")){
                self.@(method.JsVariableIsLoading)(true);
                self.@(method.JsVariableMessage)('');
                self.@(method.JsVariableWasSuccessful)(null);
                $.ajax({ method: "POST",
                         url: areaUrl + "@(method.ApiUrl)",
                         data: @method.JsPostObject,
                         xhrFields: { withCredentials: true } })
				.done(function(data) {
					self.@(method.JsVariableResultRaw)(data.object);
                    @if (method.ReturnType.PureType.HasClassViewModel) {
                    if (method.ReturnType.IsCollection)
                    {
                    @:if (self.@(method.JsVariableResult)()){
   					// Merge the incoming array
                        @if (method.ReturnType.PureType.ClassViewModel.PrimaryKey != null)
                        {
                            @:RebuildArray(self.@(method.JsVariableResult), data.object, '@method.ReturnType.PureType.ClassViewModel.PrimaryKey.JsVariable', ViewModels.@method.ReturnType.PureType.ClassViewModel.Name, self, true);
                        }
                        else if (method.ReturnType.PureType.IsPrimitive)
                        {
                            @:self.@(method.JsVariableResult)(data.object);
                        }
                        else
                        {
                            @:RebuildArray(self.@(method.JsVariableResult), data.object, null, ViewModels.@method.ReturnType.PureType.ClassViewModel.Name, self, true);
                        }
                    @:}
                    }
                    else
                    {
                    @:if (!self.@(method.JsVariableResult)()){
                    @:    self.@(method.JsVariableResult)(new ViewModels.@(method.ReturnType.PureType.ClassViewModel.Name)());
                    @:}
                    @:self.@(method.JsVariableResult)().loadFromDto(data.object);
                    }
                    }
                    else {
                    @:self.@(method.JsVariableResult)(data.object);
                    }
                    
                    if (reload) {
                      self.load(callback);
                    } else if ($.isFunction(callback)) {
                      callback(data);
                    }
				})
				.fail(function(xhr) {
                    var errorMsg = "Unknown Error";
                    if (xhr.responseJSON && xhr.responseJSON.message) errorMsg = xhr.responseJSON.message;
                    self.@(method.JsVariableWasSuccessful)(false);
                    self.@(method.JsVariableMessage)(errorMsg);

					//alert("Could not call method @method.JsVariable: " + errorMsg);
				})
				.always(function() {
                    self.@(method.JsVariableIsLoading)(false);
				});
            }

            self.@method.JsVariableUi = function(callback?: any) {
                @foreach(var param in method.ClientParameters.Where(f=>f.ConvertsFromJsString))
                {
                @:var @param.Name.ToCamelCase(): @param.Type.TsType = @param.Type.TsConvertFromString($"prompt('{param.Name.ToProperCase()}')");
                }
                @foreach(var param in method.ClientParameters.Where(f=>!f.ConvertsFromJsString))
                {
                @:var @param.Name: @param.Type.TsType = null;
                }
                self.@(method.JsVariable)(@(method.JsArguments("", true)));
            }

            self.@method.JsVariableModal = function(callback?: any) {
                @if (method.ClientParameters.Any()) { 
                @:$('#method-@method.Name').modal();
                @:$('#method-@method.Name').on('shown.bs.modal', function() {
                    @:$('#method-@method.Name .btn-ok').unbind('click');
                    @:$('#method-@method.Name .btn-ok').click(function()
                    @:{
                        @:self.@(method.JsVariableWithArgs)(null, callback);
                        @:$('#method-@method.Name').modal('hide');
                    @:});
                @:});
                }
                else
                {
                    @:self.@(method.JsVariableUi)(callback);
                }
            }
            
            @if (method.ClientParameters.Any()) { 
            @:self.@(method.JsVariableWithArgs) = function(args?: @(model.ListViewModelClassName).@(method.ArgsName), callback?: any) {
                @:if (!args) args = self.@(method.JsVariableArgs);
                @:self.@(method.JsVariable)(@(method.JsArguments("args", true)));
            @:}
            }

            </text>
            }
        }
    }

    export namespace @(model.ListViewModelClassName) {
        // Classes for use in method calls to support data binding for input for arguments
        @foreach(MethodViewModel method in model.Methods.Where(f => f.ClientParameters.Any() && f.IsStatic && f.IsClientMethod)){
        @:export class @(method.ArgsName) {
            @foreach (var arg in method.ClientParameters)
            {
            @:public @(arg.CsArgumentName): @(arg.Type.TsKnockoutType) = @(arg.Type.JsKnockoutType);
            }
        @:}
        }
    }
}